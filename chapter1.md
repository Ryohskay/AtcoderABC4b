# 1.12: String and characters
### TL;DR;
- 文字列を扱うにはstring型を使う
- 文字を扱うにはchar型を使う
- 文字列変数.size()で文字列の長さを取得できる
- 文字列変数.at(i)で
- i文字目にアクセスできる
- 文字列変数.at(i)のiを添え字という
- 添字は0から始まる
- 添字の値が正しい範囲内に無いと実行時エラーになる


# 1.13 Array
### TL;DR;
- 配列は様々なデータの列を扱うことができる機能
- `vector<型> 配列変数名;`で配列変数を宣言できる[^1]
- `配列変数名 = { 要素1, 要素2, ... };`で配列変数に値を代入できる
- `配列変数.at(i)`で<i>i</i>番目の要素にアクセスできる
- `配列変数.size()`で配列の要素数を取得できる
- `vector<型> 配列変数名(要素数)`と書くと指定した要素数で配列を初期化できる[^2]
- 配列で<i>N</i>個の入力を受け取るときは、<i>N</i>要素で初期化した後、for文の中で`.at()`を使って1ずつ受け取る

```cpp
vector<int> vec(N);
for (int i = 0; i < N; i++) {
  cin >> vec.at(i);
}
```

- 配列とfor文を組み合わせると、大量のデータを扱うプログラムを簡潔に書ける
- 配列の添字のルールは文字列と同じ

### Other Notes
#### atを使わないi番目の要素へのアクセス
`配列変数.at(添字)`と同様に、`配列変数[添字]`でも配列内の要素にアクセスできる。
ただし、この書き方では範囲外の添字を指定してしまったときにエラーメッセージが表示されずプログラムの間違いを検知しづらいので、`配列変数.at(添字)`の書き方を使う。

# 1.14 STL functions
### TL;DR;
- 関数を使うとプログラムのまとまった機能を簡単に使うことができる
- C++で用意されている、関数等がまとまっているもののことをSTL (Standard Template Library) という
- `関数名(引数1, 引数2, ...)`で関数を呼び出せる
- 関数に`( )`で渡す値のことを引数という
- 関数の計算結果のことを***返り値***または**戻り値**という
- 引数と返り値は型のルールが決まっており、間違えるとコンパイルエラーになる

### functions
- `min(a, b)`
  - aとbのうち小さい方の値を返す
- `max(a, b)`
  - aとbのうち大きい方の値を返す
- `swap(a, b)`
  - 変数aと変数bの値を交換する
  
- `sort(vec.begin(), vec.end())`
  - 配列変数vecをソートする（要素を小さい順に並び替える）

- `reverse(vec.begin(), vec.end())`
  - 配列変数vecの要素の並びを逆にする

### Execution order of arguments
- 引数の実行順序は環境によって異なります。APG4bの推奨環境である GCC-C++ では、次のように最後の引数の式から順に実行されます。

```
min(1 + 1, 2 + 2)
↓
min(1 + 1, 4)
↓
min(2, 4)
↓
2
```

- その他の環境 (Clang等) では、次のように最初の引数の式から順に実行されることがあります。
```
min(1 + 1, 2 + 2)
↓
min(2, 2 + 2)
↓
min(2, 4)
↓
2
```

このことを気にする必要がある場面は少ないですが、次の節のように自分で関数を定義する場合はハマりどころになりうるので、頭の片隅においておきましょう。

# 1.15 functions

### Other Notes
#### プロトタイプ宣言

プロトタイプ宣言をすれば関数を定義する前に呼び出すことができます。
プロトタイプ宣言とは、「関数の名前」と「引数と返り値の型」だけを先に宣言することです。

```cpp
#include <bits/stdc++.h>
using namespace std;

// プロトタイプ宣言
void hello();

int main() {
  // プロトタイプ宣言をしたので呼び出せる
  hello();
}

void hello() {
  cout << "hello!" << endl;
  return;
}
```

実行結果:
```
hello!
```
- プロトタイプ宣言の記法は次のようになります。
```
返り値の型 関数名(引数1の型 引数1の名前, 引数2の型 引数2の名前, ...);
```

#### 引数名の省略

引数の名前は省略することもできます。
例えば、my_min関数のプロトタイプ宣言は次のように書くこともできます。
```cpp
int my_min(int, int);
```

#### returnの省略

返り値がない場合、関数の末尾ではreturnを省略できます。
```cpp
void hello(string text) {
  cout << "Hello, " << text << "!" << endl;
}
```

#### 関数のオーバーロード overloading
「引数の型」または「引数の数」が異なる場合は、同じ名前の関数を定義することができます。これを関数のオーバーロードと言います。
次のプログラムでは「2つの引数を取るmy_min関数」と「3つの引数を取るmy_min関数」を定義しています。
```cpp
#include <bits/stdc++.h>
using namespace std;

// 2つの引数のうち最も小さい値を返す
int my_min(int x, int y) {
  if (x < y) {
    return x;
  }
  else {
    return y;
  }
}

// 3つの引数のうち最も小さい値を返す
int my_min(int x, int y, int z) {
  if (x < y && x < z) {
    return x;
  }
  else if (y < x && y < z) {
    return y;
  }
  else {
    return z;
  }
}

int main() {
  int answer = my_min(10, 5); // 2つの引数
  cout << answer << endl; // 5

  answer = my_min(3, 2, 5); // 3つの引数
  cout << answer << endl; // 2
}
```
ただし、**返り値の型が異なるだけではオーバーロードできない**ことに注意してください。 

[^1]: `vector<T> name(N);` 以外にも `T name[N]` (e.g. `int data[3]`) などで配列を初期化できるが、vector以外の表現にはいろいろと問題点や落とし穴があるので可能な限り避けるべき。ただし`T name[N]`に関しては他の人のソースコードでよく見るかも。
[^2]: `vector<int>`の場合は全ての要素が0で初期化. `vector<string> vec(3)`の場合は空の文字列の配列`{"", "", ""}`で初期化
